name: CI/CD

# This workflow:
# - Builds and publishes Docker images for every Git tag (weekly/manual) or just the release tag (on release).
# - Additionally, on any push that changes the Dockerfile, it builds the image for the current commit as a CI check without publishing.
# - Adds a success gate job that runs after the CI build and returns success if the CI build succeeded.

on:
    schedule:
        # Runs at 02:00 UTC every Sunday.
        - cron: '0 2 * * 0'
    # Allows you to run this workflow manually from the Actions tab on GitHub.
    workflow_dispatch:
    # Triggers when a new release is published.
    release:
        types: [published]
    # CI check: build only when Dockerfile changes on push (no publish).
    push:
        paths:
            - Dockerfile

env:
    REGISTRY: ghcr.io
    IMAGE_NAME: ${{ github.repository }}

jobs:
    ## -----------------------------------------------------------------
    ## Job 0: CI build for current commit when Dockerfile changes (no publish)
    ## -----------------------------------------------------------------
    ci-build:
        if: ${{ github.event_name == 'push' }}
        runs-on: ubuntu-latest
        permissions:
            contents: read
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Build Docker image (no push) for current commit
              uses: docker/build-push-action@v6
              with:
                  context: .
                  file: ./Dockerfile
                  push: false        # do not publish; CI check only
                  load: false        # do not load into local docker
                  pull: true         # ensure base images are pulled/validated
                  # Optional ephemeral tag helpful in logs (not pushed/loaded)
                  tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:ci-${{ github.sha }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max

    ## -----------------------------------------------------------------
    ## Job 0.1: CI success gate â€” runs after ci-build and returns success if ci-build succeeded
    ## - Runs only on push events (Dockerfile path filter from the trigger)
    ## - Executes even if ci-build failed, and sets outcome explicitly based on ci-build result
    ## -----------------------------------------------------------------
    success:
        name: CI Success Gate
        needs: ci-build
        if: ${{ github.event_name == 'push' && always() }}
        runs-on: ubuntu-latest
        permissions:
            contents: read
        steps:
            - name: Report CI build outcome
              run: |
                  echo "ci-build result: ${{ needs.ci-build.result }}"
                  if [ "${{ needs.ci-build.result }}" = "success" ]; then
                    echo "Dockerfile CI build for commit $GITHUB_SHA succeeded."
                    exit 0
                  else
                    echo "Dockerfile CI build did not succeed (result=${{ needs.ci-build.result }})."
                    exit 1
                  fi

    ## -----------------------------------------------------------------
    ## Job 1: Get tags to build (skipped on push/Dockerfile CI)
    ## - On scheduled/manual runs: outputs a JSON list of all tags.
    ## - On release runs: outputs a JSON list with only the release tag.
    ## -----------------------------------------------------------------
    list-tags:
        if: ${{ github.event_name != 'push' }}
        runs-on: ubuntu-latest
        outputs:
            # The output is a JSON array string of tag names, e.g., ["v1.0", "v1.1"]
            tags: ${{ steps.get-tags.outputs.tags }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  # Fetch all history and tags
                  fetch-depth: 0

            - name: Get tags for this run (all tags on schedule/manual, release tag on release)
              id: get-tags
              env:
                  EVENT_NAME: ${{ github.event_name }}
                  RELEASE_TAG: ${{ github.event.release.tag_name }}
              run: |
                  if [ "$EVENT_NAME" = "release" ] && [ -n "$RELEASE_TAG" ]; then
                    echo "Detected release event for tag: $RELEASE_TAG"
                    echo "tags=[\"$RELEASE_TAG\"]" >> "$GITHUB_OUTPUT"
                  else
                    tags=$(git tag | jq -R -s -c 'split("\n")[:-1]')
                    echo "Detected non-release event, building all tags: $tags"
                    echo "tags=$tags" >> "$GITHUB_OUTPUT"

    ## -----------------------------------------------------------------
    ## Job 2: Build and publish an image for each tag (skipped on push/Dockerfile CI)
    ## -----------------------------------------------------------------
    build-and-publish:
        if: ${{ github.event_name != 'push' && needs.list-tags.outputs.tags != '[]' }}
        runs-on: ubuntu-latest
        needs: list-tags
        permissions:
            contents: read      # to checkout private repos
            packages: write     # to push images to GHCR
            id-token: write     # to sign images with Sigstore

        strategy:
            # This ensures that if one tag fails to build, the others will still be attempted.
            fail-fast: false
            # Creates a parallel job for each tag in the JSON array from the 'list-tags' job.
            matrix:
                tag: ${{ fromJson(needs.list-tags.outputs.tags) }}

        steps:
            - name: Checkout code for tag ${{ matrix.tag }}
              uses: actions/checkout@v4
              with:
                  # Checks out the specific Git tag for this job run.
                  ref: ${{ matrix.tag }}

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Log into registry ${{ env.REGISTRY }}
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            - name: Extract Docker metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
                  # Explicitly sets the Docker tag to be the same as the Git tag from the matrix.
                  tags: type=raw,value=${{ matrix.tag }}

            - name: Build and push Docker image
              id: build-and-push
              uses: docker/build-push-action@v6
              with:
                  context: .
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max

            - name: Install cosign
              uses: sigstore/cosign-installer@v3
              with:
                  cosign-release: 'v2.2.4'

            - name: Sign the published Docker image
              env:
                  TAGS: ${{ steps.meta.outputs.tags }}
                  DIGEST: ${{ steps.build-and-push.outputs.digest }}
                # This step uses the identity token to sign the image digest.
              run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}