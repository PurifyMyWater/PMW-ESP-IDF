name: CI/CD

# This workflow:
# - Builds and publishes Docker images for every Git tag (scheduled/manual) or just the release tag (on release).
# - On manual runs, you can choose:
#     - publish (checkbox): whether to push to GHCR
#     - dry_run (checkbox): list expected tags only (no build, no push)
# - Additionally, on any push that changes the Dockerfile, it builds the image for the current commit as a CI check without publishing.
# - Adds a success gate job that runs after the CI build and returns success if the CI build succeeded.

on:
    # Runs at 02:00 UTC on the 1st day of every month.
    schedule:
        -   cron: '0 2 1 * *'
    # Allows you to run this workflow manually from the Actions tab on GitHub.
    workflow_dispatch:
        inputs:
            publish:
                description: 'Publish image to GHCR? (Schedule and release always publish)'
                type: boolean
                required: false
                default: false
            dry_run:
                description: 'Dry run (list expected tags only; no build, no push)'
                type: boolean
                required: false
                default: false
    # Triggers when a new release is published.
    release:
        types: [ published ]
    # CI check: build only when Dockerfile changes on push (no publish).
    push:
        paths:
            - Dockerfile

env:
    REGISTRY: ghcr.io
    IMAGE_NAME: ${{ github.repository }} # may contain uppercase (e.g., PurifyMyWater/PMW-ESP-IDF)

jobs:
    ## -----------------------------------------------------------------
    ## Job 0: CI build for the current commit when Dockerfile changes (no publish)
    ## -----------------------------------------------------------------
    ci-build:
        if: ${{ github.event_name == 'push' }}
        runs-on: ubuntu-latest
        permissions:
            contents: read
        steps:
            -   name: Checkout repository
                uses: actions/checkout@v4

            -   name: Set up Docker Buildx
                uses: docker/setup-buildx-action@v3

            -   name: Normalize image name to lowercase
                run: echo "IMAGE_NAME_LC=$(echo '${{ env.IMAGE_NAME }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"

            -   name: Build Docker image (no push) for current commit
                uses: docker/build-push-action@v6
                with:
                    context: .
                    file: ./Dockerfile
                    push: false        # do not publish; CI check only
                    load: false        # do not load into local docker
                    pull: true         # ensure base images are pulled/validated
                    # Optional ephemeral tag helpful in logs (not pushed/loaded)
                    tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LC }}:ci-${{ github.sha }}
                    cache-from: type=gha
                    cache-to: type=gha,mode=max

    ## -----------------------------------------------------------------
    ## Job 0.1: CI success gate — runs after ci-build and returns success if ci-build succeeded
    ## - Runs only on push events (Dockerfile path filter from the trigger)
    ## - Executes even if ci-build failed, and sets outcome explicitly based on ci-build result
    ## -----------------------------------------------------------------
    success:
        needs: ci-build
        if: ${{ github.event_name == 'push' && always() }}
        runs-on: ubuntu-latest
        permissions:
            contents: read
        steps:
            -   name: Report CI build outcome
                run: |
                    echo "ci-build result: ${{ needs.ci-build.result }}"
                    if [ "${{ needs.ci-build.result }}" = "success" ]; then
                      echo "Dockerfile CI build for commit $GITHUB_SHA succeeded."
                      exit 0
                    else
                      echo "Dockerfile CI build did not succeed (result=${{ needs.ci-build.result }})."
                      exit 1
                    fi

    ## -----------------------------------------------------------------
    ## Job 1: Get tags to build (skipped on push/Dockerfile CI)
    ## - On scheduled/manual runs: outputs a JSON list of all tags.
    ## - On release runs: outputs a JSON list with only the release tag.
    ## -----------------------------------------------------------------
    list-tags:
        if: ${{ github.event_name != 'push' }}
        runs-on: ubuntu-latest
        outputs:
            # The output is a JSON array string of tag names, e.g., ["v1.0", "v1.1"]
            tags: ${{ steps.get-tags.outputs.tags }}
        steps:
            -   name: Checkout repository
                uses: actions/checkout@v4
                with:
                    fetch-depth: 0

            -   name: Get tags for this run (all tags on schedule/manual, release tag on release)
                id: get-tags
                env:
                    EVENT_NAME: ${{ github.event_name }}
                    RELEASE_TAG: ${{ github.event.release.tag_name }}
                run: |
                    if [ "$EVENT_NAME" = "release" ] && [ -n "$RELEASE_TAG" ]; then
                      echo "Detected release event for tag: $RELEASE_TAG"
                      echo "tags=[\"$RELEASE_TAG\"]" >> "$GITHUB_OUTPUT"
                    else
                      tags=$(git tag | jq -R -s -c 'split("\n")[:-1]')
                      echo "Detected non-release event, building all tags: $tags"
                      echo "tags=$tags" >> "$GITHUB_OUTPUT"
                    fi

    ## -----------------------------------------------------------------
    ## Job 1.1: Dry run output — list expected tags only (no build/push)
    ## - Runs only when manually dispatched with dry_run=true
    ## -----------------------------------------------------------------
    dry-run-output:
        needs: list-tags
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run }}
        runs-on: ubuntu-latest
        steps:
            -   name: Normalize image name to lowercase
                run: echo "IMAGE_NAME_LC=$(echo '${{ env.IMAGE_NAME }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"

            -   name: Print expected tags and write to summary
                env:
                    TAGS: ${{ needs.list-tags.outputs.tags }}
                    REGISTRY: ${{ env.REGISTRY }}
                run: |
                    echo "Dry run: listing expected tags only (no build, no push)."
                    echo "Git tags JSON: $TAGS"
                    
                    # Build the list of expected Docker tags
                    lines=$(echo "$TAGS" | jq -r '.[]' | sed "s#^#${REGISTRY}/${IMAGE_NAME_LC}:#")
                    
                    # Print to logs
                    echo "Expected Docker image tags:"
                    echo "$lines"
                    
                    # Append a nice Markdown section to the Job Summary
                    {
                      echo "## Dry run: expected Docker image tags"
                      echo
                      echo "- Repository: ${REGISTRY}/${IMAGE_NAME_LC}"
                      echo "- Tag count: $(echo "$TAGS" | jq 'length')"
                      echo
                      echo '```'
                      echo "$lines"
                      echo '```'
                    } >> "$GITHUB_STEP_SUMMARY"

    ## -----------------------------------------------------------------
    ## Job 2: Build and publish an image for each tag (skipped on push/Dockerfile CI)
    ## - For schedule and release: always publish.
    ## - For workflow_dispatch: publish only if input checkbox is true.
    ## - Skipped entirely on dry_run.
    ## -----------------------------------------------------------------
    build-and-publish:
        if: ${{ github.event_name != 'push' && needs.list-tags.outputs.tags != '[]' && !(github.event_name == 'workflow_dispatch' && inputs.dry_run) }}
        runs-on: ubuntu-latest
        needs: list-tags
        permissions:
            contents: read      # to check out private repos
            packages: write     # to push images to GHCR
            id-token: write     # to sign images with Sigstore

        strategy:
            # This ensures that if one tag fails to build, the others will still be attempted.
            fail-fast: true
            # Creates a parallel job for each tag in the JSON array from the 'list-tags' job.
            matrix:
                tag: ${{ fromJson(needs.list-tags.outputs.tags) }}

        steps:
            -   name: Checkout code for tag ${{ matrix.tag }}
                uses: actions/checkout@v4
                with:
                    ref: ${{ matrix.tag }}

            -   name: Set up Docker Buildx
                uses: docker/setup-buildx-action@v3

            -   name: Normalize image name to lowercase
                run: echo "IMAGE_NAME_LC=$(echo '${{ env.IMAGE_NAME }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"

            -   name: Log into registry ${{ env.REGISTRY }}
                if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && inputs.publish) }}
                uses: docker/login-action@v3
                with:
                    registry: ${{ env.REGISTRY }}
                    username: ${{ github.actor }}
                    password: ${{ secrets.GITHUB_TOKEN }}

            -   name: Extract Docker metadata
                id: meta
                uses: docker/metadata-action@v5
                with:
                    images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LC }}
                    tags: type=raw,value=${{ matrix.tag }}

            -   name: Build image (conditionally push)
                id: build-and-push
                uses: docker/build-push-action@v6
                with:
                    context: .
                    push: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && inputs.publish) }}
                    tags: ${{ steps.meta.outputs.tags }}
                    labels: ${{ steps.meta.outputs.labels }}
                    cache-from: type=gha
                    cache-to: type=gha,mode=max

            -   name: Install cosign
                if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && inputs.publish) }}
                uses: sigstore/cosign-installer@v3
                with:
                    cosign-release: 'v2.2.4'

            -   name: Sign the published Docker image
                if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && inputs.publish) }}
                env:
                    TAGS: ${{ steps.meta.outputs.tags }}
                    DIGEST: ${{ steps.build-and-push.outputs.digest }}
                run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}