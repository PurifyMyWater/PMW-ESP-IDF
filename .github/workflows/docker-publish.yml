name: Weekly Tag Publisher

# This workflow builds and publishes a Docker image for every Git tag in the repository.
# It runs automatically once a week and can also be triggered manually.

on:
  schedule:
    # Runs at 02:00 UTC every Sunday.
    - cron: '0 2 * * 0'
  # Allows you to run this workflow manually from the Actions tab on GitHub.
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  ## -----------------------------------------------------------------
  ## Job 1: Get all Git tags
  ## This job checks out the repository and outputs a JSON list of all tags.
  ## -----------------------------------------------------------------
  list-tags:
    runs-on: ubuntu-latest
    outputs:
      # The output is a JSON array string of all tag names, e.g., ["v1.0", "v1.1"]
      tags: ${{ steps.get-tags.outputs.tags }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch all history and tags
          fetch-depth: 0

      - name: Get all tags and format as JSON
        id: get-tags
        # The `git tag` command lists all tags.
        # `jq` is a tool that formats the list into a JSON array, which is required by the matrix strategy in the next job.
        run: echo "tags=$(git tag | jq -R -s -c 'split("\n")[:-1]')" >> $GITHUB_OUTPUT

  ## -----------------------------------------------------------------
  ## Job 2: Build and publish an image for each tag
  ## This job runs for each tag found by the 'list-tags' job.
  ## -----------------------------------------------------------------
  build-and-publish:
    runs-on: ubuntu-latest
    # This job requires the 'list-tags' job to complete successfully first.
    needs: list-tags
    # This condition prevents the job from running if the repository has no tags.
    if: ${{ needs.list-tags.outputs.tags != '[]' }}
    permissions:
      contents: read      # to checkout private repos
      packages: write      # to push images to GHCR
      id-token: write      # to sign images with Sigstore

    strategy:
      # This ensures that if one tag fails to build, the others will still be attempted.
      fail-fast: false
      # Creates a parallel job for each tag in the JSON array from the 'list-tags' job.
      matrix:
        tag: ${{ fromJson(needs.list-tags.outputs.tags) }}

    steps:
      - name: Checkout code for tag ${{ matrix.tag }}
        uses: actions/checkout@v4
        with:
          # Checks out the specific Git tag for this job run.
          ref: ${{ matrix.tag }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          # Explicitly sets the Docker tag to be the same as the Git tag from the matrix.
          tags: type=raw,value=${{ matrix.tag }}

      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.4'

      - name: Sign the published Docker image
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
        # This step uses the identity token to sign the image digest.
        run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
